import os
import sys
import time
import hashlib
#import requests
import platform
#from prettytable import PrettyTable
import pefile
import sys
from docx import Document
import re

# List of suspicious functions to check for
SUSPICIOUS_FUNCTIONS = [
    'CreateRemoteThread',
    'WriteProcessMemory',
    
    # Add more functions as needed
]

suspicious_strings = [
        "exec(", "eval(", "os.system(", "os.popen(", "__import__(",
        "subprocess.Popen(", "pickle.loads(", "shlex.split(",
        "input(", "open(", "write(", "read(", "socket(",
        "bind(", "connect(", "send(", "recv(", "accept("
]
#as Mentioned loading the 'hashes.txt' file into the program
def load_known_hashes(file_path):
    """Load known malware hashes from a file."""
    with open(file_path, "r") as f:
        return {line.strip() for line in f}

# Loading the 'signature.txt' file into the program
def load_signatures(signature_file):
    signatures = {}
    with open(signature_file, 'r') as f:
        for line in f:
            if line.strip():  # Ignore empty lines
                signature, file_type = line.strip().split(',', 1)
                # Convert the signature from hex string to bytes
                signature_bytes = bytes.fromhex(signature.strip().replace(" ", ""))
                signatures[signature_bytes] = file_type.strip()
    return signatures
##
####
##### Reading the contents of the file without executing it
def read_file_content(filepath):
    """
    Reads the content of a file and returns it as a string.
    Supports .txt and .docx files.

    :param filepath: str, the path to the file.
    :return: str, the content of the file.
    """
    file_extension = os.path.splitext(filepath)[1].lower()

    if file_extension == '.txt':
        with open(filepath, 'r') as file:
            return file.read()
    elif file_extension == '.docx':
        doc = Document(filepath)
        return "\n".join([para.text for para in doc.paragraphs])
    else:
        raise ValueError("Unsupported file type: {}".format(file_extension))
# This is for Calculating the hash of the file uploaded by the user

def calculate_hash(file_path):
    """Calculate the SHA-256 hash of a file."""
    sha256_hash = hashlib.sha256()
    with open(file_path, "rb") as f:
        for byte_block in iter(lambda: f.read(4096), b""):
            sha256_hash.update(byte_block)
    return sha256_hash.hexdigest()

def check_suspicious_functions_in_file(filepath):
    """
    Checks for the presence of suspicious function names in the provided file.

    :param filepath: str, the path to the file to search through.
    :param suspicious_functions: list of str, the suspicious function names to search for.
    :return: None, prints the results directly.
    """
    # Create a dictionary to store occurrences of suspicious functions
    found_functions = {func: 0 for func in SUSPICIOUS_FUNCTIONS}

    # Read the file content
    code_text = read_file_content(filepath)

    # Scan through the code text and count occurrences of each suspicious function
    for func in SUSPICIOUS_FUNCTIONS:
        # Use regular expressions to find all occurrences of the function name
        matches = re.findall(r'\b{}\b'.format(re.escape(func)), code_text)
        # Count the number of matches
        found_functions[func] = len(matches)

    # Print results
    results = {}
    suspicious_found = False
    #print_r = None
    for func, count in found_functions.items():
        if count > 0:
            #print(f"Suspicious function found: {func} (Occurrences: {count})")
            suspicious_found = True
            results[func] = f"Suspicious function found: {func} (Occurrences: {count})"
    if not suspicious_found:
        results['file_sus_func'] = "No suspicious functions found."
    else:
        results['file_sus_func'] = "Suspicious functions detected."
    
    return results


def check_suspicious_functions(pe):
    # Create a list to store found suspicious functions
    found_functions = []
    
    # Iterate over imported modules
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        module_name = entry.dll.decode()
        for imp in entry.imports:
            if imp.name:
                func_name = imp.name.decode()
                if func_name in SUSPICIOUS_FUNCTIONS:
                    found_functions.append(func_name)
    
    return found_functions

def check_suspicious_strings(file_path):
    
     # Determine the file type and call the appropriate function
    _, file_extension = os.path.splitext(file_path)
    results = {}
    if file_extension =='.docx':
        try:
            doc = Document(file_path)
            suspicious_found = False
            for para_num, para in enumerate(doc.paragraphs, start=1):
                for suspicious in suspicious_strings:
                    if suspicious in para.text:
                        results[suspicious]=f"Found suspicious string '{suspicious}' in paragraph {para_num} of {file_path}"
                        results['file_str']="Suspicious strings found"
                        suspicious_found = True
                        break  # Stop checking after finding the suspicious string in this paragraph
            if not suspicious_found:
                results['file_str']="No suspicious string found"
        except Exception as e:
            print(f"Error processing {file_path}: {str(e)}")
    elif file_extension == '.txt':  # Include other text file types if needed
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:
                content = file.read()
                suspicious_found = False
                for suspicious in suspicious_strings:
                    if suspicious in content:
                        results[suspicious]=f"Found suspicious string '{suspicious}' in {file_path}"
                        results['file_str']="Suspicious strings found"
                        suspicious_found = True
                        break  # Stop checking after finding the suspicious string
                if not suspicious_found:
                    results['file_str']="No suspicious string found"
        except Exception as e:
            print(f"Error processing {file_path}: {str(e)}")
    else:
        print(f"Unsupported file type: {file_extension}")
    return results

def check_file_attributes(file_path):
    """Check file attributes for suspicious characteristics."""
    file_size = os.path.getsize(file_path)
    return {
        "file_size": file_size
    }

def get_file_signature(file_path, num_bytes=8):
    with open(file_path, 'rb') as f:
        return f.read(num_bytes)

def identify_file_type(file_path, signatures):
    file_signature = get_file_signature(file_path)
    for signature, file_type in signatures.items():
        if file_signature.startswith(signature):
            return file_type
    return 'Unknown file type'

def read_file_header(file_path, num_bytes=64):
    with open(file_path, 'rb') as f:
        return f.read(num_bytes)

def analyze_file(file_path,known_hashes,signatures):
    """Perform a basic analysis of the file."""
    print(f"Analyzing file: {file_path}")
 # Calculate and display the file hash
    file_hash = calculate_hash(file_path)
    print(f"SHA-256 Hash: {file_hash}")

    # Compare the file hash with known malware hashes
    if file_hash in known_hashes:
        print("Warning: File hash matches a known malware hash!")
    else:
        print("File hash does not match any known malware hash.")
#

    if file_path.endswith('.txt'):
        file_type = 'txt'
    else:
        file_type = identify_file_type(file_path, signatures)

    print(file_type)
    if file_type == 'Windows executable (EXE)':
        # Checking Suspicious functions of PE File
        try:
            pe = pefile.PE(file_path)
        except Exception as e:
            print(f"Error loading PE file: {e}")
            return
        
        # Check for suspicious functions in PE file
        found_functions = check_suspicious_functions(pe)
        if found_functions:
            print("Suspicious functions found:", ', '.join(found_functions))
        else:
            print("No suspicious functions found.")
    
    elif file_type == 'txt':
        # Read the file content
        #code_text = read_file_content(file_path)
        
        # Check for suspicious functions in text-based files
        result = check_suspicious_functions_in_file(file_path)
        print (result)
        # Print results
        #check for suspicious strings
        print("Checking strings")
        resultstr=check_suspicious_strings(file_path)
        print (resultstr)
        
    else:
        print("Unsupported file type.")

    # Check file attributes
    file_attributes = check_file_attributes(file_path)
    print(f"File Size: {file_attributes['file_size']} bytes")

    
    if file_type == 'Unknown file type':
        print(f"File {file_path} might be suspicious.")
    else:
        print(f"File type: {file_type}")

    # Read and print the file header
    file_header = read_file_header(file_path)
    print(f"File Header: {file_header.hex()}")

def main():
    
    uploads_dir = "uploads"
    # Define the path to the file containing known malware hashes
    known_hashes_file = "hashes.txt"
    # Load known malware hashes
    known_hashes = load_known_hashes(known_hashes_file)
    signature_file = "signatures.txt"
     # Load file signatures
    signatures = load_signatures(signature_file)
    # Check if the directory exists
    if os.path.isdir(uploads_dir):
        # Iterate over all files in the directory
        for file_name in os.listdir(uploads_dir):
            file_path = os.path.join(uploads_dir, file_name)
            if os.path.isfile(file_path):
                analyze_file(file_path, known_hashes, signatures)
            else:
                print(f"Skipping {file_path}: not a file")
    else:
        print(f"Directory {uploads_dir} does not exist")

def scan_files(directory, known_hashes_file, signature_file):
    known_hashes = load_known_hashes(known_hashes_file)
    signatures = load_signatures(signature_file)

    results = []
    for file_name in os.listdir(directory):
        file_path = os.path.join(directory, file_name)
        if os.path.isfile(file_path):
            file_result = {}
            file_result['name'] = file_name
            
            file_hash = calculate_hash(file_path)
            file_result['hash'] = file_hash

            if file_hash in known_hashes:
                file_result['hash_status'] = "Warning: File hash matches a known malware hash!"
            else:
                file_result['hash_status'] = "File hash does not match any known malware hash."
            
            file_type = None
            if file_path.endswith('.txt'):
                file_type = 'txt'
            else:
                file_type = identify_file_type(file_path, signatures)

            file_result['file_type'] = file_type
            
            file_attributes = check_file_attributes(file_path)
            file_result['file_size'] = f"{file_attributes['file_size']} bytes"

            file_header = read_file_header(file_path)
            file_result['file_header'] = file_header.hex()

            if file_type in ['txt', 'DOCX document']:
                #print("Cherker 1")
                
                func_results = check_suspicious_functions_in_file(file_path) #printed out
                #print("che2")
                file_result['file_sus_func'] = func_results
                #file_result['file_sus_func'] = func_results
                print(func_results)
                print (file_result['file_sus_func'] )
               # print("check5")

                #Trying to add suspicious function here
                str_results = check_suspicious_strings(file_path) #printed out
                file_result['file_str']=str_results
            
            elif file_type == 'Windows executable (EXE)':
                try:
                    pe = pefile.PE(file_path)
                except Exception as e:
                    print(f"Error loading PE file: {e}")
                    file_result['file_sus_func'] = "Error loading PE file"
                    results.append(file_result)
                    continue

                found_functions = check_suspicious_functions(pe)
                if found_functions:
                    print("Suspicious functions found:", ', '.join(found_functions))
                    file_result['file_sus_func'] = "Suspicious functions found: " + ', '.join(found_functions)
                else:
                    print("No suspicious functions found.")
                    file_result['file_sus_func'] = "No suspicious functions found." 

            else:
                print("Unsupported file type.")
                file_result['file_sus_func'] = "Unsupported File Type"           

            results.append(file_result)
    
    return results

if __name__ == "__main__":
    main()

